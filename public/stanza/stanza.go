package stanza

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/wanderer69/MorphologicalSentenceParser/public/entity"
	stanzaclient "github.com/wanderer69/MorphologicalSentenceParser/public/stanza_client"
	universaldependencies "github.com/wanderer69/MorphologicalSentenceParser/public/universal_dependencies"
	ocorp "github.com/wanderer69/OpCorpora/public/opcorpora"
)

type Stanza struct {
	isHaveInit           bool
	stanzaClient         *stanzaclient.StanzaClient
	universalDependecies *universaldependencies.UniversalDependencies
}

func NewStanza() *Stanza {
	ud := universaldependencies.NewUniversalDependencies()
	stanzaClient := stanzaclient.NewStanzaClient()
	n := Stanza{
		stanzaClient:         stanzaClient,
		universalDependecies: ud,
	}

	ocorp.GlobalDictInit()
	return &n
}

func (n *Stanza) Init() error {
	err := n.stanzaClient.Init()
	if err != nil {
		return err
	}
	time.Sleep(time.Duration(5) * time.Second)
	n.isHaveInit = true
	return nil
}

func (n *Stanza) ExecParseSentence(sentence string) (string, error) {
	if !n.isHaveInit {
		return "", fmt.Errorf("not initialized")
	}
	ctx := context.Background()
	return n.stanzaClient.ParsePhrase(ctx, sentence)
}

func (n *Stanza) Close() {
	n.stanzaClient.Close()
}

type AutoGenerated [][]struct {
	ID        int      `json:"id"`
	Text      string   `json:"text"`
	Lemma     string   `json:"lemma"`
	Upos      string   `json:"upos"`
	Feats     string   `json:"feats,omitempty"`
	Head      int      `json:"head"`
	Deprel    string   `json:"deprel"`
	StartChar int      `json:"start_char"`
	EndChar   int      `json:"end_char"`
	Ner       string   `json:"ner"`
	MultiNer  []string `json:"multi_ner"`
	Misc      string   `json:"misc,omitempty"`
}

func (n *Stanza) ParseSentence(str string) ([]entity.WordData, error) {
	res, err := n.ExecParseSentence(str)
	if err != nil {
		fmt.Printf("ParseSentence: error %v\r\n", err)
		return nil, err
	}
	//var ss [][]map[string]string
	var ss AutoGenerated
	wds := []entity.WordData{}
	err = json.Unmarshal([]byte(res), &ss)
	if err != nil {
		fmt.Printf("ParseSentence: error %v\r\n", err)
		return nil, err
	}
	s := ss[0]
	for i := range s {
		wd := entity.WordData{}
		fmt.Printf("-> %#v\r\n", s[i])
		_, vn := ocorp.Tag2StrAttrInt(s[i].Upos)
		if len(vn) > 0 {
			wd.Pos = vn
		} else {
			wd.Pos = s[i].Upos
		}

		/*
			err := json.Unmarshal([]byte(s[i].Feats), &s)
			if err != nil {
				fmt.Printf("ParseSentence: error %v\r\n", err)
				return nil, err
			}
		*/
		if len(s[i].Feats) > 0 {
			props := strings.Split(s[i].Feats, "|")
			if len(props) > 0 {
				sm := make(map[string]string)
				for j := range props {
					vvs := strings.Split(props[j], "=")
					fmt.Printf("i %v props[%v] %vvvs %v\r\n", i, j, props[j], vvs)
					vv := strings.ToLower(vvs[1])
					sn, vn := ocorp.Tag2StrAttrRuInt(vv)
					if len(vn) > 0 {
						sm[sn] = vn
					} else {
						if true {
							fmt.Printf("-> %v, %v\r\n", vvs[0], vv)
						}
					}
				}
				wd.Feats = sm
			}
		}
		wd.IdN = int(s[i].ID)
		wd.StartN = int(s[i].StartChar)
		wd.StopN = int(s[i].EndChar)
		wd.HeadIdN = s[i].Head
		wd.Lemma = s[i].Lemma
		vn = n.universalDependecies.Tag2StrByUniversalDependecies(s[i].Deprel)
		if len(vn) > 0 {
			wd.Rel = vn
		} else {
			wd.Rel = s[i].Deprel
		}
		wd.Text = s[i].Text
		/*
			for k, v := range s[i] {
				switch k {
				case "rel":
					vn := n.universalDependecies.Tag2StrByUniversalDependecies(v)
					if len(vn) > 0 {
						wd.Rel = vn
					} else {
						wd.Rel = v
					}
				case "pos":
					_, vn := ocorp.Tag2StrAttrInt(v)
					if len(vn) > 0 {
						wd.Pos = vn
					} else {
						wd.Pos = v
					}
				case "feats":
					var s map[string]string
					err := json.Unmarshal([]byte(v), &s)
					if err != nil {
						fmt.Printf("ParseSentence: error %v\r\n", err)
						return nil, err
					}
					for nn, vv := range s {
						vv := strings.ToLower(vv)
						sn, vn := ocorp.Tag2StrAttrRuInt(vv)
						if len(vn) > 0 {
							s[sn] = vn
						} else {
							if false {
								fmt.Printf("-> %v, %v\r\n", nn, vv)
							}
						}
					}
					wd.Feats = s
				case "start":
					wd.Start = v
				case "stop":
					wd.Stop = v
				case "text":
					wd.Text = v
				case "lemma":
					wd.Lemma = v
				case "id":
					wd.Id = v
					sl := strings.Split(v, "_")
					sn, err := strconv.ParseInt(sl[0], 10, 64)
					if err != nil {
						fmt.Printf("ParseSentence: error %v\r\n", err)
						return nil, err
					}
					pn, err := strconv.ParseInt(sl[1], 10, 64)
					if err != nil {
						fmt.Printf("ParseSentence: error %v\r\n", err)
						return nil, err
					}
					wd.IdN = int(pn)
					wd.SidN = int(sn)
				case "head_id":
					wd.HeadID = v
					sl := strings.Split(v, "_")
					sn, err := strconv.ParseInt(sl[0], 10, 64)
					if err != nil {
						fmt.Printf("ParseSentence: error %v\r\n", err)
						return nil, err
					}
					pn, err := strconv.ParseInt(sl[1], 10, 64)
					if err != nil {
						fmt.Printf("ParseSentence: error %v\r\n", err)
						return nil, err
					}
					wd.HeadIdN = int(pn)
					wd.SheadIdN = int(sn)
				}
			}
		*/

		wds = append(wds, wd)
	}

	return wds, nil
}
